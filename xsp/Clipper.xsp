

%module{Math::Clipper};
%package{Math::Clipper};

%{
#include <myinit.h>

PROTOTYPES: DISABLE

IV
_constant()
  ALIAS:
    CT_INTERSECTION = ctIntersection
    CT_UNION = ctUnion
    CT_DIFFERENCE = ctDifference
    CT_XOR = ctXor
    PT_SUBJECT = ptSubject
    PT_CLIP = ptClip
    PFT_EVENODD = pftEvenOdd
    PFT_NONZERO = pftNonZero
    PFT_POSITIVE = pftPositive
    PFT_NEGATIVE = pftNegative
    JT_MITER = jtMiter
    JT_ROUND = jtRound
    JT_SQUARE = jtSquare
    ET_CLOSED_POLYGON = etClosedPolygon
    ET_CLOSED_LINE = etClosedLine
    ET_OPEN_BUTT = etOpenButt
    ET_OPEN_SQUARE = etOpenSquare
    ET_OPEN_ROUND = etOpenRound
    ZFT_NONE = zftNone
    ZFT_MAX = zftMax
    ZFT_MIN = zftMin
    ZFT_BOTH_MAX = zftBothMax
    ZFT_BOTH_MIN = zftBothMin
    ZFT_INTERPOLATE_MEAN = zftInterpolateMean
    ZFT_BOTH_UINT32 = zftBothUInt32
    ZFT_ALL_UINT16 = zftAllUInt16
    ZFT_BOTH_MAX_FLAGS = zftBothMaxFlags
  CODE:
    RETVAL = ix;
  OUTPUT: RETVAL

%}

%name{Math::Clipper}
class Clipper {
  Clipper();
  ~Clipper();

%{

ClipperLib::Paths*
execute(THIS, clipType, subjFillType = pftEvenOdd, clipFillType = pftEvenOdd, zfill = zftNone)
    Clipper* THIS
    ClipType clipType
    PolyFillType subjFillType
    PolyFillType clipFillType
    ZFillType zfill
  CODE:
    RETVAL = new ClipperLib::Paths();
#ifdef use_xyz
    set_zfill_callback(*THIS, zfill);
#endif
    THIS->Execute(clipType, *RETVAL, subjFillType, clipFillType);
#ifdef use_xyz
    zfill_postprocess(*RETVAL, clipType, zfill);
#endif
  OUTPUT:
    RETVAL

ExPolygons*
ex_execute(THIS, clipType, subjFillType = pftEvenOdd, clipFillType = pftEvenOdd, zfill = zftNone)
    Clipper* THIS
    ClipType clipType
    PolyFillType subjFillType
    PolyFillType clipFillType
    ZFillType zfill
  CODE:
    PolyTree* polytree = new ClipperLib::PolyTree();
#ifdef use_xyz
    set_zfill_callback(*THIS, zfill);
#endif
    THIS->Execute(clipType, *polytree, subjFillType, clipFillType);
#ifdef use_xyz
    zfill_postprocess_pt(*polytree, clipType, zfill);
#endif
    RETVAL = new ExPolygons();
    PolyTreeToExPolygons(*polytree, *RETVAL);
    delete polytree;
  OUTPUT:
    RETVAL

ClipperLib::PolyTree*
pt_execute(THIS, clipType, subjFillType = pftEvenOdd, clipFillType = pftEvenOdd, zfill = zftNone)
    Clipper* THIS
    ClipType clipType
    PolyFillType subjFillType
    PolyFillType clipFillType
    ZFillType zfill
  CODE:
    RETVAL = new ClipperLib::PolyTree();
#ifdef use_xyz
    set_zfill_callback(*THIS, zfill);
#endif
    THIS->Execute(clipType, *RETVAL, subjFillType, clipFillType);
#ifdef use_xyz
    zfill_postprocess_pt(*RETVAL, clipType, zfill);
#endif
  OUTPUT:
    RETVAL
%}

// No longer in v4.X
//  %name{get_force_orientation}
//    bool ForceOrientation();
//  %name{set_force_orientation}
//    void ForceOrientation(bool value);

// We don't expose this since we save the PolyType stuff entirely that way!
//  %name{add_polygon}
//    void AddPolygon(const Polygon &pg, PolyType polyType);

%{

void
add_subject_polygon(self, poly)
    Clipper* self
    ClipperLib::Path* poly
  PPCODE:
    self->AddPath(*poly, ptSubject, true);
    delete poly;

void
add_clip_polygon(self, poly)
    Clipper* self
    ClipperLib::Path* poly
  PPCODE:
    self->AddPath(*poly, ptClip, true);
    delete poly;

void
add_subject_polygons(self, polys)
    Clipper* self
    ClipperLib::Paths* polys
  PPCODE:
    self->AddPaths(*polys, ptSubject, true);
    delete polys;

void
add_clip_polygons(self, polys)
    Clipper* self
    ClipperLib::Paths* polys
  PPCODE:
    self->AddPaths(*polys, ptClip, true);
    delete polys;

void
add_subject_polyline(self, poly)
    Clipper* self
    ClipperLib::Path* poly
  PPCODE:
    self->AddPath(*poly, ptSubject, false);
    delete poly;

void
add_clip_polyline(self, poly)
    Clipper* self
    ClipperLib::Path* poly
  PPCODE:
    self->AddPath(*poly, ptClip, false);
    delete poly;

void
add_subject_polylines(self, polys)
    Clipper* self
    ClipperLib::Paths* polys
  PPCODE:
    self->AddPaths(*polys, ptSubject, false);
    delete polys;

void
add_clip_polylines(self, polys)
    Clipper* self
    ClipperLib::Paths* polys
  PPCODE:
    self->AddPaths(*polys, ptClip, false);
    delete polys;

bool
preserve_collinear(self, ...)
    Clipper* self
  CODE:
    if (items > 1) { self->PreserveCollinear(SvIV(ST(1)) == 0 ? false : true); }
    RETVAL = self->PreserveCollinear();
  OUTPUT:
    RETVAL

bool
strictly_simple(self, ...)
    Clipper* self
  CODE:
    if (items > 1) { self->StrictlySimple(SvIV(ST(1)) == 0 ? false : true); }
    RETVAL = self->StrictlySimple();
  OUTPUT:
    RETVAL

double
orientation(polygon)
    ClipperLib::Path* polygon
  CODE:
    RETVAL = ClipperLib::Orientation(*polygon);
    delete polygon;
  OUTPUT: RETVAL

double
area(polygon)
    ClipperLib::Path* polygon
  CODE:
    RETVAL = ClipperLib::Area(*polygon);
    delete polygon;
  OUTPUT: RETVAL

ClipperLib::Paths*
_offset(polygons, delta, jointype=jtMiter, MiterLimit, endtype=etClosedPolygon)
    ClipperLib::Paths* polygons
    const float delta
    JoinType jointype
    const double MiterLimit
    EndType endtype
  CODE:
    RETVAL = new ClipperLib::Paths();
    //ClipperLib::OffsetPolygons(*polygons, *RETVAL, delta, jointype, MiterLimit);
    ClipperLib::ClipperOffset co;
    co.MiterLimit = MiterLimit;
    co.AddPaths(*polygons, jointype, endtype);
    co.Execute(*RETVAL, delta);
    co.Clear();
    delete polygons;
  OUTPUT:
    RETVAL

ClipperLib::Paths*
int_offset(polygons, delta, scale, jointype, MiterLimit, endtype = etClosedPolygon)
    ClipperLib::Paths* polygons
    const float delta
    const double scale
    JoinType jointype
    const double MiterLimit
    EndType endtype
  CODE:
    RETVAL = _int_offset(polygons, delta, scale, jointype, MiterLimit, endtype);
    delete polygons;
  OUTPUT:
    RETVAL

ClipperLib::Paths*
int_offset2(polygons, delta1, delta2, scale, jointype, MiterLimit, endtype=etClosedPolygon)
    ClipperLib::Paths* polygons
    const float delta1
    const float delta2
    const double scale
    JoinType jointype
    const double MiterLimit
    EndType endtype
  CODE:
    // scale
    _scale_polygons(polygons, scale);
    
    // perform first offset
    ClipperLib::Paths* offset1 = new ClipperLib::Paths();
    //ClipperLib::OffsetPolygons(*polygons, *offset1, (delta1*scale), jointype, MiterLimit);
    ClipperLib::ClipperOffset co;
    co.MiterLimit = MiterLimit;
    co.AddPaths(*polygons, jointype, endtype);
    co.Execute(*offset1, (delta1*scale));
    co.Clear();
    
    // perform second offset
    RETVAL = new ClipperLib::Paths();
    //ClipperLib::OffsetPolygons(*offset1, *RETVAL, (delta2*scale), jointype, MiterLimit);
    co.AddPaths(*offset1, jointype, endtype);
    co.Execute(*RETVAL, delta2);
    co.Clear();

    // unscale
    _scale_polygons(RETVAL, 1/scale);
    
    // cleanup
    delete offset1;
    delete polygons;
  OUTPUT:
    RETVAL

ExPolygons*
ex_int_offset(polygons, delta, scale, jointype, MiterLimit, endtype = etClosedPolygon)
    ClipperLib::Paths* polygons
    const float delta
    const double scale
    JoinType jointype
    const double MiterLimit
    EndType endtype
  CODE:
    Clipper clpr;
    clpr.Clear();
    ClipperLib::Paths* offset = _int_offset(polygons, delta, scale, jointype, MiterLimit, endtype);
    clpr.AddPaths(*offset, ptSubject, true);
    PolyTree* polytree = new ClipperLib::PolyTree();
    clpr.Execute(ctUnion, *polytree, pftEvenOdd, pftEvenOdd);  // offset results work with both EvenOdd and NonZero
    
    RETVAL = new ExPolygons();
    PolyTreeToExPolygons(*polytree, *RETVAL);
    
    // cleanup
    delete polygons;
    delete offset;
    delete polytree;
  OUTPUT:
    RETVAL

ExPolygons*
ex_int_offset2(polygons, delta1, delta2, scale, jointype, MiterLimit, endtype = etClosedPolygon)
    ClipperLib::Paths* polygons
    const float delta1
    const float delta2
    const double scale
    JoinType jointype
    const double MiterLimit
    EndType endtype
  CODE:
    // scale
    _scale_polygons(polygons, scale);
    
    // perform first offset
    ClipperLib::Paths* offset1 = new ClipperLib::Paths();
    //ClipperLib::OffsetPolygons(*polygons, *offset1, (delta1*scale), jointype, MiterLimit);
    ClipperLib::ClipperOffset co;
    co.MiterLimit = MiterLimit;
    co.AddPaths(*polygons, jointype, endtype);
    co.Execute(*offset1, (delta1*scale));
    co.Clear();
    
    // perform second offset
    ClipperLib::Paths* offset2 = new ClipperLib::Paths();
    //ClipperLib::OffsetPolygons(*offset1, *offset2, (delta2*scale), jointype, MiterLimit);
    co.AddPaths(*offset1, jointype, endtype);
    co.Execute(*offset2, (delta2*scale));
    co.Clear();
    
    // unscale
    _scale_polygons(offset2, 1/scale);
    
    // perform UNION
    Clipper clpr;
    clpr.Clear();
    clpr.AddPaths(*offset2, ptSubject, true);
    PolyTree* polytree = new ClipperLib::PolyTree();
    clpr.Execute(ctUnion, *polytree, pftEvenOdd, pftEvenOdd);  // offset results work with both EvenOdd and NonZero
    
    // convert result to ExPolygons
    RETVAL = new ExPolygons();
    PolyTreeToExPolygons(*polytree, *RETVAL);
    
    // cleanup
    delete polygons;
    delete offset1;
    delete offset2;
    delete polytree;
  OUTPUT:
    RETVAL

ClipperLib::Paths*
polylines_offset(polylines, delta, jointype, endtype = etOpenButt, limit)
    ClipperLib::Paths* polylines
    const float delta
    JoinType jointype
    EndType endtype
    const double limit
  CODE:
    RETVAL = new ClipperLib::Paths();
    //ClipperLib::OffsetPaths(*polylines, *RETVAL, delta, jointype, endtype, limit);
    ClipperLib::ClipperOffset co;
    co.MiterLimit = limit;
    co.AddPaths(*polylines, jointype, endtype);
    co.Execute(*RETVAL, delta);
    co.Clear();
    delete polylines;
  OUTPUT:
    RETVAL

# singular version simplify_polygon() removed in 6.0.0
ClipperLib::Paths*
simplify_polygon(polygon, fillType)
    ClipperLib::Path* polygon
    PolyFillType fillType
  PREINIT:
    ClipperLib::Paths* polygons;
  CODE:
    RETVAL = new ClipperLib::Paths();
    polygons = new ClipperLib::Paths();
    polygons->push_back(*polygon);
    ClipperLib::SimplifyPolygons(*polygons, *RETVAL, fillType);
    delete polygon;
    delete polygons;
  OUTPUT:
    RETVAL

ClipperLib::Paths*
simplify_polygons(polygons, fillType)
    ClipperLib::Paths* polygons
    PolyFillType fillType
  CODE:
    RETVAL = new ClipperLib::Paths();
    ClipperLib::SimplifyPolygons(*polygons, *RETVAL, fillType);
    delete polygons;
  OUTPUT:
    RETVAL

int
has_z()
  CODE:
    RETVAL = CLIPPER_HAS_Z;
  OUTPUT:
    RETVAL

%}

  %name{clear}
    void Clear();

};



